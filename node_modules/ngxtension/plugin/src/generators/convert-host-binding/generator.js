"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertHostBindingGenerator = convertHostBindingGenerator;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_process_1 = require("node:process");
const ts_morph_1 = require("ts-morph");
const contents_store_1 = require("../shared-utils/contents-store");
const CLASS_DECORATORS = ['Component', 'Directive'];
function trackContents(tree, contentsStore, fullPath) {
    if (fullPath.endsWith('.ts')) {
        const fileContent = tree.read(fullPath, 'utf8') || (0, node_fs_1.readFileSync)(fullPath, 'utf8');
        const decorators = CLASS_DECORATORS.map((decoratorName) => `@${decoratorName}`);
        if (!decorators.some((decorator) => fileContent.includes(decorator))) {
            devkit_1.logger.log(`[ngxtension] "${fullPath}" is not a Component nor a Directive`);
            return;
        }
        if (fileContent.includes('@HostBinding') ||
            fileContent.includes('@HostListener')) {
            contentsStore.track(fullPath, fileContent);
        }
    }
}
function convertHostBindingGenerator(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contentsStore = new contents_store_1.ContentsStore();
        const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
        const angularCorePackage = packageJson['dependencies']['@angular/core'];
        if (!angularCorePackage) {
            devkit_1.logger.error(`[ngxtension] No @angular/core detected`);
            return (0, node_process_1.exit)(1);
        }
        const { path, project } = options;
        if (path && project) {
            devkit_1.logger.error(`[ngxtension] Cannot pass both "path" and "project" to convertHostBinding`);
            return (0, node_process_1.exit)(1);
        }
        /** Track contents in the store */
        if (path) {
            if (!tree.exists(path)) {
                devkit_1.logger.error(`[ngxtension] "${path}" does not exist`);
                return (0, node_process_1.exit)(1);
            }
            trackContents(tree, contentsStore, path);
        }
        else if (project) {
            try {
                const projectConfiguration = (0, devkit_1.readProjectConfiguration)(tree, project);
                if (!projectConfiguration) {
                    throw `"${project}" project not found`;
                }
                (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfiguration.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
            catch (err) {
                devkit_1.logger.error(`[ngxtension] ${err}`);
                return;
            }
        }
        else {
            const projects = (0, devkit_1.getProjects)(tree);
            for (const project of projects.values()) {
                (0, devkit_1.visitNotIgnoredFiles)(tree, project.root, (path) => {
                    trackContents(tree, contentsStore, path);
                });
            }
        }
        /** end Track contents in the store */
        for (const { path: sourcePath } of contentsStore.collection) {
            const sourceFile = contentsStore.project.getSourceFile(sourcePath);
            addHostProperty(sourceFile);
            removeHostBindingOrHostListenerImport(sourceFile);
            tree.write(sourcePath, sourceFile.getFullText());
        }
    });
}
const removeHostBindingOrHostListenerImport = (sourceFile) => {
    const packageDir = '@angular/core';
    const foundImports = sourceFile
        .getImportDeclaration((importDeclaration) => importDeclaration.getModuleSpecifierValue() === packageDir)
        .getNamedImports()
        .filter((namedImport) => namedImport.getName() === 'HostBinding' ||
        namedImport.getName() === 'HostListener');
    if (foundImports.length) {
        foundImports.forEach((foundImport) => foundImport.remove());
    }
};
const addHostProperty = (sourceFile) => {
    sourceFile.getClasses().forEach((klass) => {
        const decorator = klass.getDecorator((decoratorDecl) => CLASS_DECORATORS.includes(decoratorDecl.getName()));
        if (!decorator) {
            return;
        }
        const hostBindings = {};
        const hostListeners = {};
        const processHostDecorators = (elements, hostBindings, hostListeners) => {
            elements.forEach((element) => {
                const hostBindingDecorator = element.getDecorator('HostBinding');
                if (hostBindingDecorator) {
                    const argument = hostBindingDecorator.getArguments()[0];
                    const binding = argument
                        ? getHostBindingKey(argument.getText())
                        : element.getName();
                    hostBindings[binding] = isMethodDeclaration(element)
                        ? `'${element.getName()}()'`
                        : `'${element.getName()}'`;
                    /** Remove the HostBinding decorator */
                    hostBindingDecorator.remove();
                }
                const hostListenerDecorator = element.getDecorator('HostListener');
                if (hostListenerDecorator) {
                    const [event, ...args] = hostListenerDecorator.getArguments();
                    const binding = getHostListenerKey(event.getText());
                    hostListeners[binding] =
                        args.length && element.getParameters().length
                            ? `'${element.getName()}(${args.map((arg) => arg.getText().replace(/^\['|'\]$/g, '')).join(', ')})'`
                            : `'${element.getName()}()'`;
                    /** Remove the HostListener decorator */
                    hostListenerDecorator.remove();
                }
            });
        };
        const processProperties = () => {
            processHostDecorators(klass.getProperties(), hostBindings, hostListeners);
        };
        const processGetters = () => {
            processHostDecorators(klass.getGetAccessors(), hostBindings, hostListeners);
        };
        const processMethods = () => {
            processHostDecorators(klass.getMethods(), hostBindings, hostListeners);
        };
        processProperties();
        processGetters();
        processMethods();
        const resolveHostProperties = (hostProperties) => {
            if (Object.keys(hostProperties).length > 0) {
                const hostProperty = decorator.getArguments()[0].getProperty('host');
                if (hostProperty) {
                    const existingHostBindings = hostProperty.getInitializerIfKindOrThrow(ts_morph_1.SyntaxKind.ObjectLiteralExpression);
                    Object.entries(hostProperties).forEach(([key, value]) => {
                        existingHostBindings.addPropertyAssignment({
                            name: key,
                            initializer: value,
                        });
                    });
                }
                else {
                    decorator.getArguments()[0].addPropertyAssignment({
                        name: 'host',
                        initializer: `{ ${Object.entries(hostProperties)
                            .map(([key, value]) => `${key}: ${value}`)
                            .join(', ')} }`,
                    });
                }
            }
        };
        const resolveHostBindings = (hostBindings) => {
            resolveHostProperties(hostBindings);
        };
        const resolveHostListeners = (hostListeners) => {
            resolveHostProperties(hostListeners);
        };
        resolveHostBindings(hostBindings);
        resolveHostListeners(hostListeners);
    });
};
const getHostBindingKey = (hostBinding) => {
    return `'[${removeQuotes(hostBinding)}]'`;
};
const getHostListenerKey = (hostListener) => {
    return `'(${removeQuotes(hostListener)})'`;
};
function removeQuotes(str) {
    return str.replace(/['"]/g, '');
}
function isMethodDeclaration(node) {
    return node.getKindName() === 'MethodDeclaration';
}
exports.default = convertHostBindingGenerator;
//# sourceMappingURL=generator.js.map