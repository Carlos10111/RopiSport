{"version":3,"file":"ngxtension-linked-query-param.mjs","sources":["../../../../libs/ngxtension/linked-query-param/src/linked-query-param.ts","../../../../libs/ngxtension/linked-query-param/src/ngxtension-linked-query-param.ts"],"sourcesContent":["import {\n\teffect,\n\tinject,\n\tInjectable,\n\tInjector,\n\trunInInjectionContext,\n\tsignal,\n\tuntracked,\n\tWritableSignal,\n} from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport {\n\tActivatedRoute,\n\tNavigationExtras,\n\tParams,\n\tRouter,\n} from '@angular/router';\nimport { assertInjector } from 'ngxtension/assert-injector';\nimport { createNotifier } from 'ngxtension/create-notifier';\nimport { distinctUntilKeyChanged, map } from 'rxjs';\n\n/**\n * The type of the stringified value.\n * After transforming the value before it is passed to the query param, this type will be used.\n */\ntype StringifyReturnType = string | number | boolean | null | undefined;\n\n/**\n * These are the options that can be passed to the `linkedQueryParam` function.\n * They are taken from the `NavigationExtras` type in the `@angular/router` package.\n */\ntype NavigateMethodFields = Pick<\n\tNavigationExtras,\n\t| 'queryParamsHandling'\n\t| 'onSameUrlNavigation'\n\t| 'replaceUrl'\n\t| 'skipLocationChange'\n>;\n\n/**\n * Service to coalesce multiple navigation calls into a single navigation event.\n */\n@Injectable({ providedIn: 'root' })\nexport class LinkedQueryParamGlobalHandler {\n\tprivate _router = inject(Router);\n\t/**\n\t * @internal\n\t * The current query params that will be set on the next navigation event.\n\t */\n\tprivate _currentKeys: Record<string, StringifyReturnType> = {};\n\t/**\n\t * @internal\n\t * The navigation extras that will be used on the next navigation event.\n\t */\n\tprivate _navigationExtras: NavigationExtras = {};\n\t/**\n\t * @internal\n\t * The notifier that will be used to schedule the navigation event.\n\t */\n\tprivate _schedulerNotifier = createNotifier();\n\n\tconstructor() {\n\t\teffect(() => {\n\t\t\t// listen to the scheduler notifier to schedule the navigation event\n\t\t\tthis._schedulerNotifier.listen();\n\n\t\t\t// we need to untrack the navigation call in order to not register any other signal as a dependency\n\t\t\tuntracked(() => void this.navigate());\n\t\t});\n\t}\n\n\t/**\n\t * Schedules the navigation event.\n\t */\n\tscheduleNavigation() {\n\t\tthis._schedulerNotifier.notify();\n\t}\n\n\t/**\n\t * Sets the value of a query param.\n\t * This will be used on the next navigation event.\n\t */\n\tsetParamKeyValue(key: string, value: StringifyReturnType) {\n\t\tthis._currentKeys[key] = value;\n\t}\n\n\t/**\n\t * Sets the navigation extras that will be used on the next navigation event.\n\t */\n\tsetCurrentNavigationExtras(config: Partial<NavigateMethodFields> = {}) {\n\t\tconst {\n\t\t\tqueryParamsHandling,\n\t\t\tonSameUrlNavigation,\n\t\t\treplaceUrl,\n\t\t\tskipLocationChange,\n\t\t} = config;\n\t\tif (queryParamsHandling || queryParamsHandling === '') {\n\t\t\tthis._navigationExtras.queryParamsHandling = queryParamsHandling;\n\t\t}\n\t\tif (onSameUrlNavigation) {\n\t\t\tthis._navigationExtras.onSameUrlNavigation = onSameUrlNavigation;\n\t\t}\n\t\tif (replaceUrl) {\n\t\t\tthis._navigationExtras.replaceUrl = replaceUrl;\n\t\t}\n\t\tif (skipLocationChange) {\n\t\t\tthis._navigationExtras.skipLocationChange = skipLocationChange;\n\t\t}\n\t}\n\n\t/**\n\t * Navigates to the current URL with the accumulated query parameters and navigation extras.\n\t * Cleans up the current keys and navigation extras after the navigation.\n\t */\n\tprivate navigate(): Promise<boolean> {\n\t\treturn this._router\n\t\t\t.navigate([], {\n\t\t\t\tqueryParams: this._currentKeys,\n\t\t\t\tqueryParamsHandling: 'merge', // can be overridden by the `queryParamsHandling` option\n\t\t\t\t...this._navigationExtras, // override the navigation extras\n\t\t\t})\n\t\t\t.then((value) => {\n\t\t\t\t// we reset the current keys and navigation extras on navigation\n\t\t\t\t// in order to avoid leaking to other navigations\n\t\t\t\tthis._currentKeys = {};\n\t\t\t\tthis._navigationExtras = {};\n\t\t\t\treturn value;\n\t\t\t});\n\t}\n}\n\ntype LinkedQueryParamOptions = {\n\t/**\n\t * The injector to use to inject the router and activated route.\n\t */\n\tinjector?: Injector;\n} & Partial<NavigateMethodFields>;\n\n/**\n * These are the function types that will be used to parse and stringify the query param value.\n */\ntype ParseFn<T> = (value: string | null) => T;\ntype StringifyFn<T> = (value: T) => StringifyReturnType;\n\n/**\n *These types will be used to define the return types of the `set` and `update` methods of the signal.\n * We need to re-type the WritableSignal, so that the set and update methods can have null in the call signature.\n * But the WritableSignal itself won't have null in the call signature, so we need to re-type it.\n * This is needed in order to be able to reset the value to null,\n * which is not possible with the WritableSignal that doesn't have null in it's type.\n */\ntype SignalSetFn<T> = (value: T) => void;\ntype SignalUpdateFn<T> = (fn: (value: T) => T) => void;\n\n/**\n * Creates a signal that is linked to a query parameter.\n *\n * You can parse the query param value before it is passed to the signal, this way you can transform the value from a string to a number or boolean or whatever you need.\n * You can also stringify the value before it is passed to the query param, this way you can stringify the value from a number or boolean or object to a string or null.\n *\n * You can also use the `defaultValue` option to set a default value if the query param is not present in the url (null or undefined).\n * NOTE: You cannot use both `defaultValue` and `parse` at the same time. You should use `parse` instead to handle the default value.\n *\n * You can set the signal to update the query parameter by calling the `set` or `update` method.\n * Both methods will accept the value + null as a valid value, so you can remove the query parameter by passing null if needed.\n *\n * The 'set' and 'update' methods will update the value synchronously, but will schedule the navigation event to\n * happen on the next tick (using root effect scheduling). This means the query params will be updated asynchronously.\n * The changes will be coalesced into a single navigation event. This means that if you call `set` or `update` multiple times\n * in a row (synchronously), only the last value will be updated in the query params.\n *\n * If you have multiple signals listening to the same query parameter, they will all be updated when the navigation event happens.\n *\n * @param key The name of the query parameter.\n * @param options Configuration options for the signal.\n * @returns A signal that is linked to the query parameter.\n */\nexport function linkedQueryParam<T = string>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & {\n\t\tparse: ParseFn<T>;\n\t\tstringify: StringifyFn<T>;\n\t},\n): WritableSignal<T> & {\n\tset: SignalSetFn<T | null>;\n\tupdate: SignalUpdateFn<T | null>;\n};\n\n/**\n * You cannot use both `defaultValue` and `parse` at the same time.\n * You should use `parse` instead to handle the default value.\n *\n * For example, you cannot do this:\n *\n * ```ts\n * linkedQueryParam('param', { defaultValue: 1, parse: (x) => x ? parseInt(x, 10) : x });\n * ```\n *\n * Instead, you should do this:\n *\n * ```ts\n * linkedQueryParam('param', { parse: (x) => x ? parseInt(x, 10) : 1 });\n * ```\n */\nexport function linkedQueryParam<T = string>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & {\n\t\tdefaultValue: Exclude<T, undefined>;\n\t\tparse: ParseFn<T>;\n\t\tstringify?: StringifyFn<T>;\n\t},\n): never;\n\nexport function linkedQueryParam<T = string>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & {\n\t\tdefaultValue: T;\n\t\tstringify: StringifyFn<T>;\n\t},\n): WritableSignal<T | null>;\n\nexport function linkedQueryParam<T>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & { defaultValue: T },\n): WritableSignal<T> & {\n\tset: SignalSetFn<T | null>;\n\tupdate: SignalUpdateFn<T | null>;\n};\n\nexport function linkedQueryParam<T>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & { defaultValue: T | null },\n): WritableSignal<T | null>;\n\nexport function linkedQueryParam<T>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & { defaultValue: T | undefined },\n): WritableSignal<T | undefined>;\n\nexport function linkedQueryParam<T = string>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & { defaultValue: undefined },\n): WritableSignal<T | null>;\n\nexport function linkedQueryParam<T>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & { parse: ParseFn<T> },\n): WritableSignal<T> & {\n\tset: SignalSetFn<T | null>;\n\tupdate: SignalUpdateFn<T | null>;\n};\n\nexport function linkedQueryParam<T = string>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions & { stringify: StringifyFn<T> },\n): WritableSignal<T | null>;\n\nexport function linkedQueryParam<T = string>(\n\tkey: string,\n\toptions: LinkedQueryParamOptions,\n): WritableSignal<T | null>;\n\nexport function linkedQueryParam<T = string>(\n\tkey: string,\n): WritableSignal<T | null>;\n\nexport function linkedQueryParam<T>(\n\tkey: string,\n\toptions?: LinkedQueryParamOptions & {\n\t\tdefaultValue?: T;\n\t\tparse?: ParseFn<T>;\n\t\tstringify?: StringifyFn<T>;\n\t},\n): WritableSignal<T> {\n\tif (options?.defaultValue !== undefined && options?.parse) {\n\t\tthrow new Error(\n\t\t\t'linkedQueryParam: You cannot have both defaultValue and parse at the same time!',\n\t\t);\n\t}\n\n\tconst injector = assertInjector(linkedQueryParam, options?.injector);\n\n\treturn runInInjectionContext(injector, () => {\n\t\tconst route = inject(ActivatedRoute);\n\t\tconst globalHandler = inject(LinkedQueryParamGlobalHandler);\n\n\t\t/**\n\t\t * Parses a parameter value based on provided configuration.\n\t\t * @param params - An object containing parameters.\n\t\t * @returns The parsed parameter value.\n\t\t */\n\t\tconst parseParamValue = (params: Params) => {\n\t\t\t// Get the value from the params object.\n\t\t\tconst value: string | null = params[key] ?? null;\n\t\t\t// If a parsing function is provided in the config, use it to parse the value.\n\t\t\tif (options?.parse) {\n\t\t\t\treturn options.parse(value);\n\t\t\t}\n\t\t\t// If the value is undefined or null and a default value is provided, return the default value.\n\t\t\tif (\n\t\t\t\t(value === undefined || value === null) &&\n\t\t\t\toptions?.defaultValue !== undefined\n\t\t\t) {\n\t\t\t\treturn options.defaultValue;\n\t\t\t}\n\t\t\t// Otherwise, return the original value or the parsed value (if it was parsed).\n\t\t\treturn value;\n\t\t};\n\n\t\t// create a signal that is updated whenever the query param changes\n\t\tconst queryParamValue = toSignal(\n\t\t\troute.queryParams.pipe(\n\t\t\t\tdistinctUntilKeyChanged(key), // skip if no changes on same key\n\t\t\t\tmap((x) => parseParamValue(x)),\n\t\t\t),\n\t\t\t{ initialValue: parseParamValue(route.snapshot.queryParams) },\n\t\t);\n\n\t\tconst source = signal<T>(queryParamValue() as T);\n\n\t\tconst originalSet = source.set;\n\n\t\teffect(() => {\n\t\t\tconst x = queryParamValue();\n\t\t\t// update the source signal whenever the query param changes\n\t\t\tuntracked(() => originalSet(x as T));\n\t\t});\n\n\t\tconst set = (value: T) => {\n\t\t\t// we first set the initial value so it synchronous (same as a normal signal)\n\t\t\toriginalSet(value);\n\n\t\t\t// when the source signal changes, update the query param\n\t\t\t// store the new value in the current keys so that we can coalesce the navigation\n\t\t\tlet valueToBeSet: any = value;\n\t\t\tif (options?.stringify) {\n\t\t\t\tvalueToBeSet = options.stringify(value);\n\t\t\t} else if (value === undefined || value === null) {\n\t\t\t\tvalueToBeSet = null;\n\t\t\t} else {\n\t\t\t\tvalueToBeSet = typeof value === 'string' ? value : String(value);\n\t\t\t}\n\n\t\t\tglobalHandler.setParamKeyValue(key, valueToBeSet);\n\t\t\tglobalHandler.setCurrentNavigationExtras(options ?? {});\n\n\t\t\t// schedule the navigation event (multiple synchronous navigations will be coalesced)\n\t\t\t// this will also reset the current keys and navigation extras after the navigation\n\t\t\tglobalHandler.scheduleNavigation();\n\t\t};\n\n\t\tconst update = (fn: (value: T) => T) => set(fn(source()));\n\n\t\treturn Object.assign(source, { set, update });\n\t});\n}\n\n/**\n * Can be used to parse a query param value to a number.\n * You can also use the `defaultValue` option to set a default value if the query param is not present in the url (null or undefined).\n *\n * Example:\n * ```ts\n * linkedQueryParam('page', { parse: paramToNumber() });\n * ```\n * Will return null if the query param is not present in the url.\n *\n * Or with a default value:\n * ```ts\n * linkedQueryParam('page', { parse: paramToNumber({defaultValue: 1}) });\n * ```\n *\n * Will return 1 if the query param is not present in the url.\n */\nexport function paramToNumber(): (x: string | null) => number | null;\nexport function paramToNumber(config: {\n\tdefaultValue: number;\n}): (x: string | null) => number;\n\nexport function paramToNumber(\n\tconfig: { defaultValue?: number | null | undefined } = { defaultValue: null },\n) {\n\treturn (x: string | null) => {\n\t\tif (x === undefined || x === null) return config.defaultValue;\n\t\tconst parsed = parseInt(x, 10);\n\t\tif (Number.isNaN(parsed)) return config.defaultValue;\n\t\treturn parsed;\n\t};\n}\n\n/**\n * Can be used to parse a query param value to a boolean.\n * You can also use the `defaultValue` option to set a default value if the query param is not present in the url (null or undefined).\n *\n * Example:\n * ```ts\n * linkedQueryParam('showHidden', { parse: paramToBoolean() });\n * ```\n * Will return null if the query param is not present in the url or true/false if the query param is present.\n *\n * Or with a default value:\n * ```ts\n * linkedQueryParam('showHidden', { parse: paramToBoolean({defaultValue: true}) });\n * ```\n *\n * Will return true if the query param is not present in the url.\n * Otherwise, it will return whatever the query param value is.\n */\nexport function paramToBoolean(): (x: string | null) => boolean | null;\nexport function paramToBoolean(config: {\n\tdefaultValue: boolean;\n}): (x: string | null) => boolean;\n\nexport function paramToBoolean(\n\tconfig: { defaultValue?: boolean | null | undefined } = {\n\t\tdefaultValue: null,\n\t},\n) {\n\treturn (x: string | null) =>\n\t\tx === undefined || x === null ? config.defaultValue : x === 'true';\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;;;AAuCA;;AAEG;MAEU,6BAA6B,CAAA;AAkBzC,IAAA,WAAA,GAAA;AAjBQ,QAAA,IAAA,CAAA,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;AACjC;;;AAGG;QACK,IAAY,CAAA,YAAA,GAAwC,EAAE,CAAC;AAC/D;;;AAGG;QACK,IAAiB,CAAA,iBAAA,GAAqB,EAAE,CAAC;AACjD;;;AAGG;QACK,IAAkB,CAAA,kBAAA,GAAG,cAAc,EAAE,CAAC;QAG7C,MAAM,CAAC,MAAK;;AAEX,YAAA,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,CAAC;;YAGjC,SAAS,CAAC,MAAM,KAAK,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;AACvC,SAAC,CAAC,CAAC;KACH;AAED;;AAEG;IACH,kBAAkB,GAAA;AACjB,QAAA,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE,CAAC;KACjC;AAED;;;AAGG;IACH,gBAAgB,CAAC,GAAW,EAAE,KAA0B,EAAA;AACvD,QAAA,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;KAC/B;AAED;;AAEG;IACH,0BAA0B,CAAC,SAAwC,EAAE,EAAA;QACpE,MAAM,EACL,mBAAmB,EACnB,mBAAmB,EACnB,UAAU,EACV,kBAAkB,GAClB,GAAG,MAAM,CAAC;AACX,QAAA,IAAI,mBAAmB,IAAI,mBAAmB,KAAK,EAAE,EAAE;AACtD,YAAA,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;SACjE;QACD,IAAI,mBAAmB,EAAE;AACxB,YAAA,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;SACjE;QACD,IAAI,UAAU,EAAE;AACf,YAAA,IAAI,CAAC,iBAAiB,CAAC,UAAU,GAAG,UAAU,CAAC;SAC/C;QACD,IAAI,kBAAkB,EAAE;AACvB,YAAA,IAAI,CAAC,iBAAiB,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;SAC/D;KACD;AAED;;;AAGG;IACK,QAAQ,GAAA;QACf,OAAO,IAAI,CAAC,OAAO;aACjB,QAAQ,CAAC,EAAE,EAAE;YACb,WAAW,EAAE,IAAI,CAAC,YAAY;YAC9B,mBAAmB,EAAE,OAAO;AAC5B,YAAA,GAAG,IAAI,CAAC,iBAAiB;SACzB,CAAC;AACD,aAAA,IAAI,CAAC,CAAC,KAAK,KAAI;;;AAGf,YAAA,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;AACvB,YAAA,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;AAC5B,YAAA,OAAO,KAAK,CAAC;AACd,SAAC,CAAC,CAAC;KACJ;8GArFW,6BAA6B,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA,EAAA;AAA7B,IAAA,SAAA,IAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,6BAA6B,cADhB,MAAM,EAAA,CAAA,CAAA,EAAA;;2FACnB,6BAA6B,EAAA,UAAA,EAAA,CAAA;kBADzC,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;AAgOlB,SAAA,gBAAgB,CAC/B,GAAW,EACX,OAIC,EAAA;IAED,IAAI,OAAO,EAAE,YAAY,KAAK,SAAS,IAAI,OAAO,EAAE,KAAK,EAAE;AAC1D,QAAA,MAAM,IAAI,KAAK,CACd,iFAAiF,CACjF,CAAC;KACF;IAED,MAAM,QAAQ,GAAG,cAAc,CAAC,gBAAgB,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;AAErE,IAAA,OAAO,qBAAqB,CAAC,QAAQ,EAAE,MAAK;AAC3C,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;AACrC,QAAA,MAAM,aAAa,GAAG,MAAM,CAAC,6BAA6B,CAAC,CAAC;AAE5D;;;;AAIG;AACH,QAAA,MAAM,eAAe,GAAG,CAAC,MAAc,KAAI;;YAE1C,MAAM,KAAK,GAAkB,MAAM,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;;AAEjD,YAAA,IAAI,OAAO,EAAE,KAAK,EAAE;AACnB,gBAAA,OAAO,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;aAC5B;;YAED,IACC,CAAC,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI;AACtC,gBAAA,OAAO,EAAE,YAAY,KAAK,SAAS,EAClC;gBACD,OAAO,OAAO,CAAC,YAAY,CAAC;aAC5B;;AAED,YAAA,OAAO,KAAK,CAAC;AACd,SAAC,CAAC;;AAGF,QAAA,MAAM,eAAe,GAAG,QAAQ,CAC/B,KAAK,CAAC,WAAW,CAAC,IAAI,CACrB,uBAAuB,CAAC,GAAG,CAAC;QAC5B,GAAG,CAAC,CAAC,CAAC,KAAK,eAAe,CAAC,CAAC,CAAC,CAAC,CAC9B,EACD,EAAE,YAAY,EAAE,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAC7D,CAAC;AAEF,QAAA,MAAM,MAAM,GAAG,MAAM,CAAI,eAAe,EAAO,CAAC,CAAC;AAEjD,QAAA,MAAM,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC;QAE/B,MAAM,CAAC,MAAK;AACX,YAAA,MAAM,CAAC,GAAG,eAAe,EAAE,CAAC;;YAE5B,SAAS,CAAC,MAAM,WAAW,CAAC,CAAM,CAAC,CAAC,CAAC;AACtC,SAAC,CAAC,CAAC;AAEH,QAAA,MAAM,GAAG,GAAG,CAAC,KAAQ,KAAI;;YAExB,WAAW,CAAC,KAAK,CAAC,CAAC;;;YAInB,IAAI,YAAY,GAAQ,KAAK,CAAC;AAC9B,YAAA,IAAI,OAAO,EAAE,SAAS,EAAE;AACvB,gBAAA,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aACxC;iBAAM,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE;gBACjD,YAAY,GAAG,IAAI,CAAC;aACpB;iBAAM;AACN,gBAAA,YAAY,GAAG,OAAO,KAAK,KAAK,QAAQ,GAAG,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;aACjE;AAED,YAAA,aAAa,CAAC,gBAAgB,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;AAClD,YAAA,aAAa,CAAC,0BAA0B,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;;;YAIxD,aAAa,CAAC,kBAAkB,EAAE,CAAC;AACpC,SAAC,CAAC;AAEF,QAAA,MAAM,MAAM,GAAG,CAAC,EAAmB,KAAK,GAAG,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;AAE1D,QAAA,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,GAAG,EAAE,MAAM,EAAE,CAAC,CAAC;AAC/C,KAAC,CAAC,CAAC;AACJ,CAAC;AAwBK,SAAU,aAAa,CAC5B,MAAA,GAAuD,EAAE,YAAY,EAAE,IAAI,EAAE,EAAA;IAE7E,OAAO,CAAC,CAAgB,KAAI;AAC3B,QAAA,IAAI,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,IAAI;YAAE,OAAO,MAAM,CAAC,YAAY,CAAC;QAC9D,MAAM,MAAM,GAAG,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC/B,QAAA,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;YAAE,OAAO,MAAM,CAAC,YAAY,CAAC;AACrD,QAAA,OAAO,MAAM,CAAC;AACf,KAAC,CAAC;AACH,CAAC;AAyBK,SAAU,cAAc,CAC7B,MAAwD,GAAA;AACvD,IAAA,YAAY,EAAE,IAAI;AAClB,CAAA,EAAA;IAED,OAAO,CAAC,CAAgB,KACvB,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,IAAI,GAAG,MAAM,CAAC,YAAY,GAAG,CAAC,KAAK,MAAM,CAAC;AACrE;;ACpaA;;AAEG;;;;"}