import { assertInInjectionContext, inject } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { ActivatedRoute } from '@angular/router';
import { map } from 'rxjs';
/**
 * Injects the params from the current route.
 * If a key is provided, it will return the value of that key.
 * If a transform function is provided, it will return the result of that function.
 * Otherwise, it will return the entire params object.
 *
 * @example
 * const userId = injectParams('id'); // returns the value of the 'id' param
 * const userId = injectParams(p => p['id'] as string); // same as above but can be used with a custom transform function
 * const params = injectParams(); // returns the entire params object
 *
 * @param keyOrTransform OPTIONAL The key of the param to return, or a transform function to apply to the params object
 */
export function injectParams(keyOrTransform) {
    assertInInjectionContext(injectParams);
    const route = inject(ActivatedRoute);
    const params = route.snapshot.params;
    if (typeof keyOrTransform === 'function') {
        return toSignal(route.params.pipe(map(keyOrTransform)), {
            initialValue: keyOrTransform(params),
        });
    }
    const getParam = (params) => keyOrTransform ? (params?.[keyOrTransform] ?? null) : params;
    return toSignal(route.params.pipe(map(getParam)), {
        initialValue: getParam(params),
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5qZWN0LXBhcmFtcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9pbmplY3QtcGFyYW1zL3NyYy9pbmplY3QtcGFyYW1zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLEVBQWUsTUFBTSxlQUFlLENBQUM7QUFDOUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQWUsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBbUIzQjs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUMzQixjQUFpRDtJQUVqRCx3QkFBd0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN2QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDckMsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFFckMsSUFBSSxPQUFPLGNBQWMsS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUMxQyxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRTtZQUN2RCxZQUFZLEVBQUUsY0FBYyxDQUFDLE1BQU0sQ0FBQztTQUNwQyxDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxRQUFRLEdBQUcsQ0FBQyxNQUFjLEVBQUUsRUFBRSxDQUNuQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUU5RCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRTtRQUNqRCxZQUFZLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQztLQUM5QixDQUFDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0LCBpbmplY3QsIHR5cGUgU2lnbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0b1NpZ25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlLCB0eXBlIFBhcmFtcyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBJbmplY3RzIHRoZSBwYXJhbXMgZnJvbSB0aGUgY3VycmVudCByb3V0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdFBhcmFtcygpOiBTaWduYWw8UGFyYW1zPjtcblxuLyoqXG4gKiBJbmplY3RzIHRoZSBwYXJhbXMgZnJvbSB0aGUgY3VycmVudCByb3V0ZSBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIGtleS5cbiAqIEBwYXJhbSBrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdFBhcmFtcyhrZXk6IHN0cmluZyk6IFNpZ25hbDxzdHJpbmcgfCBudWxsPjtcblxuLyoqXG4gKiBJbmplY3RzIHRoZSBwYXJhbXMgZnJvbSB0aGUgY3VycmVudCByb3V0ZSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBwcm92aWRlZCB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBAcGFyYW0gdHJhbnNmb3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RQYXJhbXM8VD4odHJhbnNmb3JtOiAocGFyYW1zOiBQYXJhbXMpID0+IFQpOiBTaWduYWw8VD47XG5cbi8qKlxuICogSW5qZWN0cyB0aGUgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnQgcm91dGUuXG4gKiBJZiBhIGtleSBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoYXQga2V5LlxuICogSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhhdCBmdW5jdGlvbi5cbiAqIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGVudGlyZSBwYXJhbXMgb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB1c2VySWQgPSBpbmplY3RQYXJhbXMoJ2lkJyk7IC8vIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSAnaWQnIHBhcmFtXG4gKiBjb25zdCB1c2VySWQgPSBpbmplY3RQYXJhbXMocCA9PiBwWydpZCddIGFzIHN0cmluZyk7IC8vIHNhbWUgYXMgYWJvdmUgYnV0IGNhbiBiZSB1c2VkIHdpdGggYSBjdXN0b20gdHJhbnNmb3JtIGZ1bmN0aW9uXG4gKiBjb25zdCBwYXJhbXMgPSBpbmplY3RQYXJhbXMoKTsgLy8gcmV0dXJucyB0aGUgZW50aXJlIHBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ga2V5T3JUcmFuc2Zvcm0gT1BUSU9OQUwgVGhlIGtleSBvZiB0aGUgcGFyYW0gdG8gcmV0dXJuLCBvciBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgcGFyYW1zIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0UGFyYW1zPFQ+KFxuXHRrZXlPclRyYW5zZm9ybT86IHN0cmluZyB8ICgocGFyYW1zOiBQYXJhbXMpID0+IFQpLFxuKTogU2lnbmFsPFQgfCBQYXJhbXMgfCBzdHJpbmcgfCBudWxsPiB7XG5cdGFzc2VydEluSW5qZWN0aW9uQ29udGV4dChpbmplY3RQYXJhbXMpO1xuXHRjb25zdCByb3V0ZSA9IGluamVjdChBY3RpdmF0ZWRSb3V0ZSk7XG5cdGNvbnN0IHBhcmFtcyA9IHJvdXRlLnNuYXBzaG90LnBhcmFtcztcblxuXHRpZiAodHlwZW9mIGtleU9yVHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIHRvU2lnbmFsKHJvdXRlLnBhcmFtcy5waXBlKG1hcChrZXlPclRyYW5zZm9ybSkpLCB7XG5cdFx0XHRpbml0aWFsVmFsdWU6IGtleU9yVHJhbnNmb3JtKHBhcmFtcyksXG5cdFx0fSk7XG5cdH1cblxuXHRjb25zdCBnZXRQYXJhbSA9IChwYXJhbXM6IFBhcmFtcykgPT5cblx0XHRrZXlPclRyYW5zZm9ybSA/IChwYXJhbXM/LltrZXlPclRyYW5zZm9ybV0gPz8gbnVsbCkgOiBwYXJhbXM7XG5cblx0cmV0dXJuIHRvU2lnbmFsKHJvdXRlLnBhcmFtcy5waXBlKG1hcChnZXRQYXJhbSkpLCB7XG5cdFx0aW5pdGlhbFZhbHVlOiBnZXRQYXJhbShwYXJhbXMpLFxuXHR9KTtcbn1cbiJdfQ==