import { Injector, WritableSignal } from '@angular/core';
import { NavigationExtras } from '@angular/router';
import * as i0 from "@angular/core";
/**
 * The type of the stringified value.
 * After transforming the value before it is passed to the query param, this type will be used.
 */
type StringifyReturnType = string | number | boolean | null | undefined;
/**
 * These are the options that can be passed to the `linkedQueryParam` function.
 * They are taken from the `NavigationExtras` type in the `@angular/router` package.
 */
type NavigateMethodFields = Pick<NavigationExtras, 'queryParamsHandling' | 'onSameUrlNavigation' | 'replaceUrl' | 'skipLocationChange'>;
/**
 * Service to coalesce multiple navigation calls into a single navigation event.
 */
export declare class LinkedQueryParamGlobalHandler {
    private _router;
    /**
     * @internal
     * The current query params that will be set on the next navigation event.
     */
    private _currentKeys;
    /**
     * @internal
     * The navigation extras that will be used on the next navigation event.
     */
    private _navigationExtras;
    /**
     * @internal
     * The notifier that will be used to schedule the navigation event.
     */
    private _schedulerNotifier;
    constructor();
    /**
     * Schedules the navigation event.
     */
    scheduleNavigation(): void;
    /**
     * Sets the value of a query param.
     * This will be used on the next navigation event.
     */
    setParamKeyValue(key: string, value: StringifyReturnType): void;
    /**
     * Sets the navigation extras that will be used on the next navigation event.
     */
    setCurrentNavigationExtras(config?: Partial<NavigateMethodFields>): void;
    /**
     * Navigates to the current URL with the accumulated query parameters and navigation extras.
     * Cleans up the current keys and navigation extras after the navigation.
     */
    private navigate;
    static ɵfac: i0.ɵɵFactoryDeclaration<LinkedQueryParamGlobalHandler, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<LinkedQueryParamGlobalHandler>;
}
type LinkedQueryParamOptions = {
    /**
     * The injector to use to inject the router and activated route.
     */
    injector?: Injector;
} & Partial<NavigateMethodFields>;
/**
 * These are the function types that will be used to parse and stringify the query param value.
 */
type ParseFn<T> = (value: string | null) => T;
type StringifyFn<T> = (value: T) => StringifyReturnType;
/**
 *These types will be used to define the return types of the `set` and `update` methods of the signal.
 * We need to re-type the WritableSignal, so that the set and update methods can have null in the call signature.
 * But the WritableSignal itself won't have null in the call signature, so we need to re-type it.
 * This is needed in order to be able to reset the value to null,
 * which is not possible with the WritableSignal that doesn't have null in it's type.
 */
type SignalSetFn<T> = (value: T) => void;
type SignalUpdateFn<T> = (fn: (value: T) => T) => void;
/**
 * Creates a signal that is linked to a query parameter.
 *
 * You can parse the query param value before it is passed to the signal, this way you can transform the value from a string to a number or boolean or whatever you need.
 * You can also stringify the value before it is passed to the query param, this way you can stringify the value from a number or boolean or object to a string or null.
 *
 * You can also use the `defaultValue` option to set a default value if the query param is not present in the url (null or undefined).
 * NOTE: You cannot use both `defaultValue` and `parse` at the same time. You should use `parse` instead to handle the default value.
 *
 * You can set the signal to update the query parameter by calling the `set` or `update` method.
 * Both methods will accept the value + null as a valid value, so you can remove the query parameter by passing null if needed.
 *
 * The 'set' and 'update' methods will update the value synchronously, but will schedule the navigation event to
 * happen on the next tick (using root effect scheduling). This means the query params will be updated asynchronously.
 * The changes will be coalesced into a single navigation event. This means that if you call `set` or `update` multiple times
 * in a row (synchronously), only the last value will be updated in the query params.
 *
 * If you have multiple signals listening to the same query parameter, they will all be updated when the navigation event happens.
 *
 * @param key The name of the query parameter.
 * @param options Configuration options for the signal.
 * @returns A signal that is linked to the query parameter.
 */
export declare function linkedQueryParam<T = string>(key: string, options: LinkedQueryParamOptions & {
    parse: ParseFn<T>;
    stringify: StringifyFn<T>;
}): WritableSignal<T> & {
    set: SignalSetFn<T | null>;
    update: SignalUpdateFn<T | null>;
};
/**
 * You cannot use both `defaultValue` and `parse` at the same time.
 * You should use `parse` instead to handle the default value.
 *
 * For example, you cannot do this:
 *
 * ```ts
 * linkedQueryParam('param', { defaultValue: 1, parse: (x) => x ? parseInt(x, 10) : x });
 * ```
 *
 * Instead, you should do this:
 *
 * ```ts
 * linkedQueryParam('param', { parse: (x) => x ? parseInt(x, 10) : 1 });
 * ```
 */
export declare function linkedQueryParam<T = string>(key: string, options: LinkedQueryParamOptions & {
    defaultValue: Exclude<T, undefined>;
    parse: ParseFn<T>;
    stringify?: StringifyFn<T>;
}): never;
export declare function linkedQueryParam<T = string>(key: string, options: LinkedQueryParamOptions & {
    defaultValue: T;
    stringify: StringifyFn<T>;
}): WritableSignal<T | null>;
export declare function linkedQueryParam<T>(key: string, options: LinkedQueryParamOptions & {
    defaultValue: T;
}): WritableSignal<T> & {
    set: SignalSetFn<T | null>;
    update: SignalUpdateFn<T | null>;
};
export declare function linkedQueryParam<T>(key: string, options: LinkedQueryParamOptions & {
    defaultValue: T | null;
}): WritableSignal<T | null>;
export declare function linkedQueryParam<T>(key: string, options: LinkedQueryParamOptions & {
    defaultValue: T | undefined;
}): WritableSignal<T | undefined>;
export declare function linkedQueryParam<T = string>(key: string, options: LinkedQueryParamOptions & {
    defaultValue: undefined;
}): WritableSignal<T | null>;
export declare function linkedQueryParam<T>(key: string, options: LinkedQueryParamOptions & {
    parse: ParseFn<T>;
}): WritableSignal<T> & {
    set: SignalSetFn<T | null>;
    update: SignalUpdateFn<T | null>;
};
export declare function linkedQueryParam<T = string>(key: string, options: LinkedQueryParamOptions & {
    stringify: StringifyFn<T>;
}): WritableSignal<T | null>;
export declare function linkedQueryParam<T = string>(key: string, options: LinkedQueryParamOptions): WritableSignal<T | null>;
export declare function linkedQueryParam<T = string>(key: string): WritableSignal<T | null>;
/**
 * Can be used to parse a query param value to a number.
 * You can also use the `defaultValue` option to set a default value if the query param is not present in the url (null or undefined).
 *
 * Example:
 * ```ts
 * linkedQueryParam('page', { parse: paramToNumber() });
 * ```
 * Will return null if the query param is not present in the url.
 *
 * Or with a default value:
 * ```ts
 * linkedQueryParam('page', { parse: paramToNumber({defaultValue: 1}) });
 * ```
 *
 * Will return 1 if the query param is not present in the url.
 */
export declare function paramToNumber(): (x: string | null) => number | null;
export declare function paramToNumber(config: {
    defaultValue: number;
}): (x: string | null) => number;
/**
 * Can be used to parse a query param value to a boolean.
 * You can also use the `defaultValue` option to set a default value if the query param is not present in the url (null or undefined).
 *
 * Example:
 * ```ts
 * linkedQueryParam('showHidden', { parse: paramToBoolean() });
 * ```
 * Will return null if the query param is not present in the url or true/false if the query param is present.
 *
 * Or with a default value:
 * ```ts
 * linkedQueryParam('showHidden', { parse: paramToBoolean({defaultValue: true}) });
 * ```
 *
 * Will return true if the query param is not present in the url.
 * Otherwise, it will return whatever the query param value is.
 */
export declare function paramToBoolean(): (x: string | null) => boolean | null;
export declare function paramToBoolean(config: {
    defaultValue: boolean;
}): (x: string | null) => boolean;
export {};
